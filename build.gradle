import nz.govt.natlib.m11n.tools.automation.logging.Timekeeper
import nz.govt.natlib.tools.sip.files.FilesFinder
import nz.govt.natlib.tools.sip.generation.fairfax.FairfaxFilesProcessor
import nz.govt.natlib.tools.sip.generation.fairfax.FairfaxSpreadsheet
import nz.govt.natlib.tools.sip.generation.fairfax.FairfaxFile
import nz.govt.natlib.tools.sip.pdf.PdfInformationExtractor
import nz.govt.natlib.m11n.tools.gradle.BuildException
import nz.govt.natlib.m11n.tools.gradle.ProjectHelper
import nz.govt.natlib.tools.sip.state.SipProcessingState

import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.time.LocalDate

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'nz.govt.natlib.m11n.tools:automation-plugin:1.0.0-SNAPSHOT'
        classpath 'nz.govt.natlib.m11n.tools:gradle-plugin:1.0.0-SNAPSHOT'
        classpath 'nz.govt.natlib.tools:sip-generation-gradle-plugin:1.0.0-SNAPSHOT'
        classpath 'nz.govt.natlib.tools:sip-generation-fairfax-gradle-plugin:1.0.0-SNAPSHOT'
    }
}

group 'nz.govt.natlib.tools'
description = 'National Library SIP Generation Processor for Fairfax files.'

project.ext {
    vendor = "National Library of New Zealand"
    versionNumber = "1.0.0-SNAPSHOT"

    // Command-line variables used for specific tasks

    startingDateValue = project.hasProperty('startingDate') ? project.startingDate : null
    endingDateValue = project.hasProperty('endingDate') ? project.endingDate : null

    genericSourceFolderValue = project.hasProperty('genericSourceFolder') ? project.genericSourceFolder : null

    // Task groupByDateAndName
    doGroupByDateAndName = ProjectHelper.hasAnyTasks(project, [ "groupByDateAndName", "processFiles" ])
    groupByDateAndNameSourceFolderValue = project.hasProperty('groupByDateAndNameSourceFolder') ?
            project.groupByDateAndNameSourceFolder : null
    groupByDateAndNameDestinationFolderValue = project.hasProperty('groupByDateAndNameDestinationFolder') ?
            project.groupByDateAndNameDestinationFolder : null
    groupByDateAndNameMoveFilesValue = (project.hasProperty('groupByDateAndNameMoveFiles') ?
            project.groupByDateAndNameMoveFiles : false).toBoolean()
    groupByDateAndNameCreateDestinationValue = (project.hasProperty('groupByDateAndNameCreateDestination') ?
            project.groupByDateAndNameCreateDestination : true).toBoolean()

    // Task processByDate
    doProcessByDate = ProjectHelper.hasAnyTasks(project, [ "processByDate", "processFiles" ])
    processByDateSourceFolderValue = project.hasProperty('processByDateSourceFolder') ?
            project.processByDateSourceFolder : null
    processByDateDestinationFolderValue = project.hasProperty('processByDateDestinationFolder') ?
            project.processByDateDestinationFolder : null
    processByDateMoveFilesValue = (project.hasProperty('processByDateMoveFiles') ?
            project.processByDateMoveFiles : false).toBoolean()
    processByDateCreateDestinationValue = (project.hasProperty('processByDateCreateDestination') ?
            project.processByDateCreateDestination : true).toBoolean()

    // Task processFiles
    doProcessFiles = ProjectHelper.hasAnyTasks(project, [ "processFiles" ])

    // Task listFiles
    doListFiles = ProjectHelper.hasAnyTasks(project, [ "listFiles" ])

    // Task extractMetadata
    doExtractMetadata = ProjectHelper.hasAnyTasks(project, [ "extractMetadata" ])

}

apply plugin: 'base'

setVersion(project.versionNumber)

configurations {
}

Timekeeper timekeeper = new Timekeeper()
timekeeper.start()

Closure<LocalDate> parseDate = { String dateString ->
    LocalDate parsedDate = null
    if (dateString != null) {
        parsedDate = LocalDate.parse(dateString, FairfaxFile.LOCAL_DATE_TIME_FORMATTER)
    }
    return parsedDate
}

Closure<List<File>> findFiles = { String localPath, boolean isRegexNotGlob, boolean matchFilenameOnly,
                                  boolean sortFiles, String pattern ->
    List<File> filesList = [ ]
    java.nio.file.Path filesPath = Paths.get(localPath)
    if (!Files.exists(filesPath) || !Files.isDirectory(filesPath)) {
        logger.warn("Path '${filesPath}' does not exist is not a directory. Returning empty file list.")
        return filesList
    }

    logger.info("Finding files for path=${filesPath.toFile().getCanonicalPath()} and pattern=${pattern}")
    timekeeper.logElapsed()
    filesList = FilesFinder.getMatchingFiles(filesPath, isRegexNotGlob, matchFilenameOnly, sortFiles, pattern)
    logger.info("Found total files=${filesList.size()} for path=${filesPath.toFile().getCanonicalPath()}")
    timekeeper.logElapsed()

    return filesList
}

Closure<List<File>> matchFiles = { List<File> allFiles, String pattern ->
    List<File> matchedFiles = [ ]
    allFiles.each { File file ->
        if (file.getName() ==~ /${pattern}/) {
            matchedFiles.add(file)
        }
    }

    return matchedFiles
}

Closure<Object> copyOrMoveFileToDateAndNameGroup = { File destinationFolder, FairfaxFile targetFile,
                                                     FairfaxSpreadsheet spreadsheet, boolean moveFile ->
    String dateFolderName = "${targetFile.dateYear}${targetFile.dateMonthOfYear}${targetFile.dateDayOfMonth}"
    String nameFolderName = targetFile.name
    String folderPath
    Set<String> allNameKeys = spreadsheet.allNameKeys

    if (allNameKeys.contains(targetFile.name)) {
        // There's an entry in the spreadsheet for this name
        // Goes to '<date>/<name>/<file>'
        folderPath = "${destinationFolder}${File.separator}${dateFolderName}${File.separator}${nameFolderName}"
    } else {
        // There is no entry in the spreadsheet for this name
        // Goes to 'unknown/<date>/<file>'
        folderPath = "${destinationFolder}${File.separator}unknown{File.separator}${dateFolderName}"
    }
    File destination = new File(folderPath)
    destination.mkdirs()

    if (moveFile) {
        Files.move(targetFile.file.toPath(), destination.toPath(), StandardCopyOption.COPY_ATTRIBUTES)
    } else {
        Files.copy(targetFile.file.toPath(), destination.toPath(), StandardCopyOption.COPY_ATTRIBUTES)
    }
}

task groupByDateAndName(dependsOn: [ ]) {
    File sourceFolder
    File destinationFolder
    if (project.doGroupByDateAndName) {
        if (project.groupByDateAndNameSourceFolderValue == null) {
            throw new BuildException("groupByDateAndName Source-folder=${project.groupByDateAndNameSourceFolderValue} cannot be null. Please specify a source folder using -PgroupByDateAndNameSourceFolder=<source-folder-value>")
        }
        if (project.groupByDateAndNameDestinationFolderValue == null) {
            throw new BuildException("groupByDateAndName Destination-folder=${project.groupByDateAndNameDestinationFolderValue} cannot be null. Please specify a destination folder using -PgroupByDateAndNameDestinationFolder=<destination-folder-value>")
        }
        sourceFolder = new File((String) project.groupByDateAndNameSourceFolderValue)
        if (!sourceFolder.exists() || !sourceFolder.isDirectory()) {
            throw new BuildException("groupByDateAndName Source-folder=${sourceFolder.getCanonicalPath()} must exist=${sourceFolder.exists()} and must be a directory=${sourceFolder.isDirectory()}")
        }
        destinationFolder = new File((String) project.groupByDateAndNameDestinationFolderValue)
        if (!project.groupByDateAndNameCreateDestinationValue && !destinationFolder.exists() && !sourceFolder.isDirectory()) {
            throw new BuildException("groupByDateAndName groupByDateAndNameCreateDestination=${project.groupByDateAndNameCreateDestination}, so Destination-folder=${destinationFolder.getCanonicalPath()} must exist=${destinationFolder.exists()} and must be a directory=${destinationFolder.isDirectory()}")
        }
    }
    doLast {
        if (project.doGroupByDateAndName) {
            logger.info("Starting groupByDateAndName")
            timekeeper.logElapsed()

            if (project.groupByDateAndNameCreateDestinationValue) {
                destinationFolder.mkdirs()
            }
            FairfaxSpreadsheet fairfaxSpreadsheet = FairfaxSpreadsheet.defaultInstance()

            boolean isRegexNotGlob = true
            boolean matchFilenameOnly = true
            boolean sortFiles = true

            String pattern = '\\w{6}-\\d{8}-\\w{3,4}\\.pdf'
            // Given that we could be dealing with 60,000+ files in the source directory, it's probably more efficient to
            // get them all at once
            List<File> allFiles = findFiles(sourceFolder.getAbsolutePath(), isRegexNotGlob, matchFilenameOnly, sortFiles, pattern)

            LocalDate startingDate = parseDate((String) project.startingDateValue)
            LocalDate endingDate = parseDate((String) project.endingDateValue)
            if (startingDate != null || endingDate != null) {
                // if we are using a date range then we must find by date
                if (startingDate == null) {
                    startingDate = parseDate("20170101")
                }
                if (endingDate == null) {
                    endingDate = LocalDate.now()
                }
                // Loop through the dates in sequence, finding and processing files
                LocalDate currentDate = startingDate
                while (currentDate.isBefore(endingDate)) {
                    pattern = '\\w{6}-' + FairfaxFile.LOCAL_DATE_TIME_FORMATTER.format(currentDate) + '-\\w{3,4}\\.pdf'
                    logger.info("Searching for files matching pattern=${pattern}")
                    List<File> foundFiles = matchFiles(allFiles, pattern)
                    logger.info("Found total files=${foundFiles.size()} matching pattern=${pattern}")
                    if (foundFiles.size() > 0) {
                        logger.info("Moving=${project.groupByDateAndNameMoveFilesValue} files to destination=${destinationFolder.getCanonicalPath()}")
                        foundFiles.each { File foundFile ->
                            copyOrMoveFileToDateAndNameGroup(destinationFolder, new FairfaxFile(foundFile),
                                    project.groupByDateAndNameMoveFilesValue)
                        }
                    }
                    currentDate = currentDate.plusDays(1L)
                }
            } else {
                //String pattern = ".*?\\.pdf"
                List<File> foundFiles = findFiles(sourceFolder.getAbsolutePath(), isRegexNotGlob, matchFilenameOnly, sortFiles, pattern)
                foundFiles.each { File foundFile ->
                    copyOrMoveFileToDateAndNameGroup(destinationFolder, new FairfaxFile(foundFile), fairfaxSpreadsheet,
                            project.groupByDateAndNameMoveFilesValue)
                }
            }

            logger.info("Ending groupByDateAndName")
            timekeeper.logElapsed()
        }

    }
}

Closure<Object> copyOrMoveFiles = { List<File> files, File destination, boolean moveFiles ->
    if (moveFiles) {
        files.each { File file ->
            Files.move(file.toPath(), destination.toPath(), StandardCopyOption.COPY_ATTRIBUTES)
        }
    } else {
        files.each { File file ->
            Files.copy(file.toPath(), destination.toPath(), StandardCopyOption.COPY_ATTRIBUTES)
        }
    }
}

Closure<SipProcessingState> processNameFolder = { File nameFolder, File destinationFolder, String name, String dateString,
                                          boolean moveFilesToDestination, FairfaxSpreadsheet fairfaxSpreadsheet ->
    List<Files> processedFiles = [ ]
    // Process the files in the name folder

    boolean isRegexNotGlob = true
    boolean matchFilenameOnly = true
    boolean sortFiles = true
    // Only process PDF files
    String pattern = '\\w{6}-\\d{8}-\\w{3,4}\\.pdf'
    logger.info("Searching for files matching pattern=${pattern}")

    List<File> allFiles = findFiles(nameFolder.getAbsolutePath(), isRegexNotGlob, matchFilenameOnly, sortFiles, pattern)

    SipProcessingState sipProcessingState = new SipProcessingState()
    // Process the folder as a single collection of files
    // TODO Note that there may be multiple destinations (as there could be different editions of the same name for a given day).
    String sipAsXml = FairfaxFilesProcessor.processCollectedFiles(sipProcessingState, fairfaxSpreadsheet, allFiles)

    File sipAndFilesFolder
    if (sipProcessingState.complete && sipProcessingState.successful) {
        sipAndFilesFolder = new File(destinationFolder, "${dateString}/${name}/${sipProcessingState.identifier}")
    } else {
        sipAndFilesFolder = new File(destinationFolder, "FAILURE/${dateString}/${name}")
    }
    File unrecognizedFilesFolder = new File(destinationFolder, "UNRECOGNIZED/${dateString}/${name}")

    // Move or copy the processed files to the destination folder
    copyOrMoveFiles(sipProcessingState.validFiles, sipAndFilesFolder, moveFilesToDestination)
    copyOrMoveFiles(sipProcessingState.invalidFiles, sipAndFilesFolder, moveFilesToDestination)

    // If the files aren't recognized, then dump the files in an exception folder
    copyOrMoveFiles(sipProcessingState.unrecognizedFiles, unrecognizedFilesFolder, moveFilesToDestination)

    // Write out the SipProcessingState
    File sipProcessingStateFile = new File(sipAndFilesFolder, "sipProcessingState.txt")
    sipProcessingStateFile.write(sipProcessingState.toString())

    // Write out the SIP file
    File sipFile = new File(sipAndFilesFolder, "sip.xml")
    sipFile.write(sipAsXml)

    return sipProcessingState
}

task processByDate(dependsOn: [ groupByDateAndName ]) {
    File sourceFolder
    File destinationFolder
    if (project.doProcessByDate) {
        if (project.processByDateSourceFolderValue == null) {
            throw new BuildException("processByDate Source-folder=${project.processByDateSourceFolderValue} cannot be null. Please specify a source folder using -PprocessByDateSourceFolder=<source-folder-value>")
        }
        if (project.processByDateDestinationFolderValue == null) {
            throw new BuildException("processByDate Destination-folder=${project.processByDateDestinationFolderValue} cannot be null. Please specify a destination folder using -PprocessByDateDestinationFolder=<destination-folder-value>")
        }
        sourceFolder = new File((String) project.processByDateSourceFolderValue)
        if (!sourceFolder.exists() || !sourceFolder.isDirectory()) {
            throw new BuildException("processByDate Source-folder=${sourceFolder.getCanonicalPath()} must exist=${sourceFolder.exists()} and must be a directory=${sourceFolder.isDirectory()}")
        }
        destinationFolder = new File((String) project.processByDateDestinationFolderValue)
        if (!project.processByDateCreateDestinationValue && !destinationFolder.exists() && !sourceFolder.isDirectory()) {
            throw new BuildException("processByDate processByDateCreateDestination=${project.processByDateCreateDestination}, so Destination-folder=${destinationFolder.getCanonicalPath()} must exist=${destinationFolder.exists()} and must be a directory=${destinationFolder.isDirectory()}")
        }
    }
    doLast {
        if (project.doProcessByDate) {
            if (project.processByDateCreateDestinationValue) {
                destinationFolder.mkdirs()
            }

            FairfaxSpreadsheet fairfaxSpreadsheet = FairfaxSpreadsheet.defaultInstance()

            LocalDate startingDate = parseDate((String) project.startingDateValue)
            LocalDate endingDate = parseDate((String) project.endingDateValue)

            // We always have a date range.
            if (startingDate == null) {
                startingDate = parseDate("20170101")
            }
            if (endingDate == null) {
                endingDate = LocalDate.now()
            }

            // Loop through the dates in sequence, finding and processing files
            LocalDate currentDate = startingDate
            while (currentDate.isBefore(endingDate)) {
                // The folder structure is <sourceFolder>/<date>/<name>/{files}
                String currentDateString = FairfaxFile.LOCAL_DATE_TIME_FORMATTER.format(currentDate)
                File dateFolder = new File(sourceFolder, currentDateString)
                if (dateFolder.exists() && dateFolder.isDirectory()) {
                    dateFolder.listFiles().each { File subFile ->
                        if (subFile.isDirectory()) {
                            // we want to process this directory, which should be a <name>
                            processNameFolder(subFile, destinationFolder, currentDateString, subFile.getName(),
                                    project.processByDateMoveFilesValue, fairfaxSpreadsheet)
                        } else {
                            logger.info("Skipping ${subFile.getCanonicalPath()} as not directory=${subFile.isDirectory()}")
                        }
                    }
                } else {
                    logger.info("Skipping ${dateFolder.getCanonicalPath()} as exists=${dateFolder.exists()}, directory=${dateFolder.isDirectory()}")
                }
            }
        }
    }
}

task processFiles(dependsOn: [ groupByDateAndName, processByDate ]) {
}

task listFiles(dependsOn: [ ]) {
    File sourceFolder
    if (project.doListFiles) {
        if (project.genericSourceFolderValue == null) {
            throw new BuildException("Source-folder=${project.genericSourceFolderValue} cannot be null. Please specify a source folder using -PgenericSourceFolder=<source-folder-value>")
        }
        sourceFolder = new File((String) project.genericSourceFolderValue)
    }
    doLast {
        if (project.doListFiles) {

            println("STARTING listFiles doLast")
            logger.info("sourceFolder=${project.listFilesSourceFolderValue}")

            boolean isRegexNotGlob = true
            boolean matchFilenameOnly = true
            boolean sortFiles = true
            String pattern = ".*?\\.pdf"
            List<File> foundFiles = findFiles(sourceFolder.getAbsolutePath(), isRegexNotGlob, matchFilenameOnly, sortFiles, pattern)
            List<FairfaxFile> fairfaxFiles = foundFiles.collect { File file ->
                new FairfaxFile(file)
            }

            FairfaxFile previousFile
            fairfaxFiles.each { FairfaxFile fairfaxFile ->
                if (previousFile != null) {
                    if (previousFile.name != fairfaxFile.name) {
                        println("* * * CHANGE OF PREFIX * * *")
                    } else if (previousFile.edition != fairfaxFile.edition) {
                        println("* * * CHANGE OF EDITION * * *")
                    } else if (previousFile.dateYear != fairfaxFile.dateYear &&
                            previousFile.dateMonthOfYear != fairfaxFile.dateMonthOfYear &&
                            previousFile.dateDayOfMonth != fairfaxFile.dateDayOfMonth) {
                        println("* * * CHANGE OF DATE * * *")
                    }
                }
                println(fairfaxFile)

                previousFile = fairfaxFile
            }

            timekeeper.logElapsed()
        }
    }
}

task extractMetadata() {
    File sourceFolder
    if (project.doExtractMetadata) {
        if (project.genericSourceFolderValue == null) {
            throw new BuildException("Source-folder=${project.genericSourceFolderValue} cannot be null. Please specify a source folder using -PgenericSourceFolder=<source-folder-value>")
        }
        sourceFolder = new File((String) project.genericSourceFolderValue)
    }
    doLast {
        if (project.doExtractMetadata) {
            println("STARTING extractMetadata doLast")
            if (project.sourceFolderValue == null) {
                throw new BuildException("Source-folder=${project.sourceFolderValue} cannot be null. Please specify a source folder using -PsourceFolder=<source-folder-value>")
            }
            println("sourceFolder=${sourceFolder}")
            if (!sourceFolder.exists() || !sourceFolder.isDirectory()) {
                throw new BuildException("Source-folder=${sourceFolder.getCanonicalPath()} must exist=${sourceFolder.exists()} and must be a directory=${sourceFolder.isDirectory()}")
            }
            FileNameFinder fileNameFinder = new FileNameFinder()
            List<String> filenames = fileNameFinder.getFileNames(sourceFolder.getAbsolutePath(), "**/*.pdf")
            List<File> pdfFiles = filenames.collect { String filename ->
                new File(filename)
            }

            pdfFiles.each { File pdfFile ->
                println("* * * * *")
                println("${pdfFile.getCanonicalPath()} METADATA:")
                Map<String, String> pdfMetadata = PdfInformationExtractor.extractMetadata(pdfFile)
                pdfMetadata.each { String key, String value ->
                    println("    key=${key}, value=${value}")
                }
                println("* * * * *")
                println("* * * * *")
                println("${pdfFile.getCanonicalPath()} TEXT:")
                String text = PdfInformationExtractor.extractText(pdfFile)
                println("${text}")
                println("* * * * *")
                println("* * * * *")
                println("")
            }

            timekeeper.logElapsed()
        }
    }
}
